## brisa: 一个现代化的 Go 邮件传输代理

`brisa` 是一个使用 Go 实现的、注重模块化、可扩展性和可观测性的邮件传输代理 (MTA)。

### 核心设计理念

1.  **关注点分离**: `brisa` 的核心职责是 **快速、可靠地接收邮件** 并根据策略进行分类，而不是直接投递。实际的投递、反垃圾/病毒扫描等耗时操作由独立的后端服务处理。
2.  **持久化队列**: 邮件在接收后被持久化。通过抽象的队列接口，默认使用文件系统作为队列后端，通过在不同目录间移动文件来驱动处理流程，保证了即使服务重启，邮件数据也不会丢失。
3.  **模块化与可扩展性**: 整个邮件处理流程基于中间件链构建，可以轻松地组合、添加或移除各种验证和处理逻辑。
4.  **可观测性优先**: 从设计之初就集成结构化日志、指标和追踪，确保系统状态透明、易于监控和调试。

## 架构设计

- **核心引擎 (`brisa.go`)**: 实现了 `go-smtp` 的 `Backend` 接口，负责管理 SMTP 会话的生命周期。
- **上下文 (`context.go`)**: 在整个会话期间传递状态，例如客户端 IP、会话数据等。使用 `sync.Pool` 进行复用以提高性能。
- **中间件 (`middleware.go`)**: 定义了中间件的核心接口 `type Middleware func(ctx *Context) Action`。
- **中间件链 (`middleware_chain.go`)**: 负责管理和执行注册在不同阶段的中间件。

## 未来规划与高级功能设计

以下是一些在项目原型阶段之后可以考虑引入的高级功能，旨在进一步增强 `brisa` 的可扩展性和灵活性。

### 动态中间件加载

为了能够在不重新编译主程序的情况下添加或修改业务逻辑，可以支持从外部动态加载中间件。

#### 1. 通过 Go 插件 (`.so`)

- **思路**: 使用 Go 的 `plugin` 包加载编译好的 `.so` 文件。插件需要导出一个预定义签名的函数（例如 `New() (brisa.Middleware, error)`)。
- **优点**: 原生 Go 支持，性能高。
- **挑战**: 对编译环境（Go 版本、依赖、操作系统）要求严格一致，平台支持有限（主要为 Linux）。

#### 2. 通过外部函数接口 (FFI) 调用 C ABI 兼容库 (`.so`)

- **思路**: 定义一个统一的 C 语言 ABI 接口（例如 `action_t process_mail(context_t* ctx)`），允许 `brisa` 通过 `cgo` 加载并执行由 C、C++、Rust 等语言编写的高性能原生库。
- **数据传递**:
    - **序列化 (推荐)**: 将 Go 的 `Context` 数据（特别是 `keys` map）序列化为 JSON 字符串，然后传递给 C 函数。C/C++/Rust 端使用各自的 JSON 库解析数据。这种方法安全、解耦，但有序列化开销。
    - **回调函数**: Go 导出一系列函数（使用 `//export`），C 代码通过句柄按需调用这些函数来获取上下文数据。这种方法性能更高，但实现更复杂。
- **优点**: 可利用其他语言生态中成熟的高性能库（如病毒扫描、垃圾邮件评分引擎），实现语言无关的扩展。
- **挑战**: `cgo` 带来了构建复杂性，且外部库的 Bug 可能导致整个主程序崩溃。

#### 3. 通过脚本语言

- **思路**: 嵌入一个脚本解释器（如 Starlark、Lua），执行用户提供的脚本文件作为中间件。
- **优点**: 极大地降低了自定义逻辑的门槛，脚本通常运行在沙箱中，更安全，且平台无关。
- **挑战**: 性能远低于原生代码，适用于非性能关键路径的业务逻辑。
